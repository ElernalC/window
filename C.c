C-Primer-Plus
1.数字类型关键字：（最初标准）int long short unsigned float double char
			         （C90标准）signed void
			         （C99标准）_Bool _Complex（复数） _Imaginary（虚数）

2.浮点数：浮点数存储分为两部分，小数和指数部分。

3.十六进制前缀：0x 0X   八进制前缀：0
 
4.显示十六进制：%x  八进制：%o  显示结果要出现前缀：%#x %#X   %#o

5.在C语言只规定了 short 占用的存储空间 不能多于 int，long 占用的存储空间不能少于 int，int 的大小取决于计算机的字长，范围 -32768～32767。PC上最常见的设置：long long 占 64位，long 占 32位，short 占 16位，int 占 16位或 32位（依计算机的自然字长而定）。

6.打印 unsigned int 类型的值，使用%u 转换说明。
  对于 long 类型，可以使用l前缀。%ld 表示以十进制显示 long 类型的整数，%lo 表示以八进制显示 long 类型的整数，%lx 表示以十六进制显示 long 类型的整数。
  对于 short 类型，可以使用h前缀。%hd 表示以十进制显示 short 类型的整数，%ho 表示以八进制显示 short 类型的整数，%lx 表示以十六进制显示 short 类型的整数。
  h和l前缀都可以和u一起使用，用于表示无符号类型。注意，虽然C允许使用大写或小写的常量后缀，但是在转换说明中只能用小写。
  对于支持 long long 类型的系统，%lld 和%llu 分别表示有符号和无符号类型。
  -------------------------------
  e.g.
  #include <stdio.h>
  int main(void)
  {
	unsigned int un = 3000000000; /* int为32位和short为16位的系统 */ 
	short end = 200;
	long big = 65537;
	long long verybig = 12345678908642;

	printf("un = %u and not %d\n", un, un);
	printf("end = %hd and %d\n", end, end);
	printf("big = %ld and not %hd\n", big, big); 
	printf("verybig= %lld and not %ld\n", verybig, verybig);
	 
	return 0; 
  }
  -------------------------------
  short 16位   long 32位   long long 64位   int 为32位，所以无符号范围是 0～2^32-1 (4294967295) 有符号范围是 -2147483648～2147483647
  %u 为无符号整型，un的值在这个范围里，为 3000000000，但是%d 为有符号整型，un的值不在这个范围里，会整数溢出，为 -1294967296。
  end为200，因为int类型在计算机里计算是最为高效的，short 变为 int，所以结果一样。
  big为65537和1，因为 long int 为32位，没有溢出，但是%hd 为 short，只有16位，截取结果后面一半，0000000000000001 0000000000000001 结果为 1。
  verybig与上面一样，%lld 为64位，全部显示无溢出，但是%ld 为32位，所以截取一半，只有32位，结果为 1942899938。

7.字符 char 类型存储字符，实际上确是整数，通过ASCII编码，用特定的整数表示字符。标准ASCII码的范围是 0~127，只需7位二进制数即可表示。

8.转译序列        含义
  \a      ｜  警报(ANSIC) 
  \b      ｜  退格
  \f      ｜  换页
  \n      ｜  换行
  \r      ｜  回车
  \t      ｜  水平制表符
  \v      ｜  垂直制表符
  \\      ｜  反斜杠(\)
  \’      ｜  单引号
  \”      ｜  双引号
  \?      ｜  问号
  \0oo    ｜  八进制值（oo必须是有效的八进制，即每个o可表示0～7中的一个数）
  \xhh    ｜  十六进制值（hh必须是有效的十六进制数，即每个h可表示0～f中的一个数）
  ------------------------------
  e.g.
  char beep = '\a'; 
  或
  char beep = '\007';
  ------------------------------

9.根据C90标准，C语言允许在关键字char前面使用 signed 或 unsigned。这样，无论编译器默认 char 是什么类型，signed char 表示有符号类型，而 unsigned char 表示无符号类型。这在用 char 类型处理小整数时很有用。如果只用 char 处理字符，那么 char 前面无需使用任何修饰符。

10.在C标准中规定，float 类型必须至少能表示6位有效数字，且取值范围至少是 10^(-37)～10^(+37)。通常，系统储存一个浮点数要占用32位。其中8位用于表示指数的值和符号，剩下24位用于表示非指数部分（也叫作尾数或有效数）及其符号。
   C语言提供的另一种浮点类型是 double(意为双精度)。double 类型和 float 类型的最小取值范围相同，但至少必须能表示10位有效数字。一般情况下，double 占用64位而不是32位。一些系统将多出的32位全部用来表示非指数部分，这不仅增加了有效数字的位数（即提高了精度），而且还减少了舍入误差。
   C语言的第3种浮点类型是 long double，以满足比 double 类型更高的精度要求。不过，C只保证 long double 类型至少与 double 类型的精度相同。

11.浮点值上溢和下溢，当计算导致数字过大，超过当前类型能表达的范围时，就会发生上溢。计算时失去部分有效数字，精度损失，叫作下溢。
   -----------------------------
   e.g.
   float toobig = 3.4E38 * 100.0f;/* 假设系统的最大float类型值是3.4E38 */
   printf("%e\n", toobig);
   float toosmall = 0.1234E-10 / 10;
   print("%e\n", toosmall);
   -----------------------------
   toobig将会是一个超过范围的值，发生上溢。
   toosmall四位有效数字结果为 0.0123E-10，有效数字 4丢失了，损失精度，发生下溢。

12. sizeof 是C语言的内置运算符，以字节为单位给出指定类型的大小。

13. scanf("%d", &weight)函数调用有两个参数:"%d"和 &weight。注意参数个数，"%d"也是参数。

14. strlen()函数获取字符串的字符长度。
    ----------------------------
    e.g.
    char name[40];
    scanf("%s",name);
    ----------------------------
    name表示地址，所以不需要取址符&。

    ----------------------------
    e.g.
    #include <stdio.h>
    #include <string.h> /* 提供strlen()函数的原型 */ 
    #define PRAISE "You are an extraordinary being."
    int main(void) 
    {
        char name[40];
        printf("What's your name? ");
        scanf("%s", name);

        printf("Hello, %s.%s\n", name, PRAISE);
        printf("Your name of %zd letters occupies %zd memory cells.\n",strlen(name), sizeof (name));
        printf("The phrase of praise has %zd letters ",strlen(PRAISE));
        printf("and occupies %zd memory cells.\n", sizeof PRAISE); 
        return 0;
    }
    ---------------------------
    Your name of 11 letters occupies 40 memory cells.
    从结果可看出，strlen()计算name数组内存储的字符串长度是11，没有计入空字符\0，但是 sizeof 运算符算出name数组有40个存储单元。

15.在C语言中没有专门用于储存字符串的变量类型，字符串都被储存在 char 类型的数组中。数组由连续的存储单元组成，字符串中的字符被储存在相邻的存储单元中，每个单元储存一个字符。
   数组末尾位置的字符\0是空字符(null character)，C语言用它标记字符串的结束。空字符不是数字0，它是非打印字符，其ASCII码值是（或等价于）0。
   C中的字符串一定以空字符结束，这意味着数组的容量必须至少比待存储字符串中的字符数多1。
   数组如果有40位，那前39位存储数据，最后一位存储\0。    

16.一般而言，根据%s转换说明，scanf()只会读取字符串中的一个单词，而不是一整句。C语言还有其他的输入函数（如，fgets()），用于读取一般字符串。

17. const 限定符，将变量改为只读。
    ---------------------------
    e.g.
    const int months = 12
    ---------------------------

18.对于浮点类型，有用于 double 和 long double 类型的转换说明，却没有 float 类型的。

19.实际上，计算机不能真正用浮点数除以整数，编译器会把两个运算对象转换成相同的类型。

20.%zd，格式符z和整数转换说明符一起使用，表示对应数字是一个size_t值。属于C99。

21.*修饰符，可以用它来代替字段宽度。但是还要有参数告诉函数，字段宽度是多少。如果转换说明是%*d，参数列表应包含*和d对应的值。
   ----------------------------
   e.g.
   #include <stdio.h>
   int main(void)
   {
       unsigned width, precision;
       int number = 256;
       double weight = 242.5;
       printf("Enter a field width:\n");
       scanf("%d", &width);
       printf("The number is :%*d:\n", width, number);
       
       printf("Now enter a width and a precision:\n"); 
       scanf("%d %d", &width, &precision); 
       printf("Weight = %*.*f\n", width, precision, weight); 
       printf("Done!\n");
       return 0; 
   }
   ----------------------------

22. sizeof 运算符和 size_t 类型，sizeof 返回 size_t 类型的值。这是一个无符号整数类型，但它不是新类型，它是创建的别名。
   ----------------------------
   e.g.
   #include <stdio.h> 
   int main(void)
   {
       int n = 0;
       size_t intsize;
       intsize = sizeof (int);
       printf("n = %d, n has %zd bytes; all ints have %zd bytes.\n",n, sizeof n, intsize); 
       return 0;
   }
   ----------------------------

23.单独使用递增运算符时（如i++;或++j；），使用哪种形式都没关系。但是，当运算符和运算对象是更复杂表达式的一部分时（如 q=2*++a；或q=2*a++；），使用前缀或后缀的效果不同。
   ----------------------------
   e.g.
   前缀形式
   q = 2 * a++; /*首先，a递增1；
                  然后，2乘以a，并将结果赋给q。*/

   后缀形式
   q = 2 * ++a; /*首先，2乘以a，并将结果赋给q；
                  然后，a递增1。*/
   ----------------------------
   （递减运算符也是如此）

24.在C中，每个表达式都有一个值。语句是C的基本构建块，一条语句相当于完整的计算机指令，但并不是所有的指令都是语句。
   -----------------------------
   e.g.
   legs = 4     /*只是一个表达式。*/

   legs = 4;    /*一条语句，在C中，大部分语句都以分号结尾。*/

   ;            /*最简单的语句，空语句*/

   int i        /*声明创建了名称和类型， 并为其分配内存位置。注意，声明不是表达式语句。删去;号，剩下的部分不是表达式。*/
   -----------------------------

25.副作用和序列点
   -----------------------------
   e.g.
   states = 50; /*从C语言的角度看，主要目的是对表达式求值，给出表达式states = 50，C会对其求值得50。
                  对该表达式求值的副作用是把变量states的值改为50。*/

   while (guests++ < 10)           
     printf("%d \n", guests); /*表达式 guests++ < 10 是一个完整的表达式，因为它是while循环的测试条件，所以该表达式的结束就是一个序列点。
                                     因此，C保证了在程序转至执行 printf() 之前发生副作用(即，递增guests)。
                                     同时，使用后缀形式保证了 guests 在完成与 10 的比较后才进行递增。*/
   ----------------------------
   副作用 是对数据对象或文件的修改。

   序列点 (sequence point)是程序执行的点，在该点上，所有的副作用都在进入下一步之前发生。
   在C语言中，语句中的分号标记了一个序列点。意思是，在一个语句中，赋值运算符、递增运算符和递减 运算符对运算对象做的改变必须在程序执行下一条语句之前完成。
   另外，任何一个完整表达式 的结束也是一个序列点。

26.（类型名）强制类型转换。如：mine = (int)1.8;

27.实参和形参。为遵循这一规定，我们可以说形参是变量，实参是函数调用提供的值，实参被赋给相应的形参。
   ----------------------------
   e.g.
   #include <stdio.h>
   void pound(int n);

   int main(void)
   {
   int times = 5;
   char ch = '!'; 
   pound(times);     /*times为实参。*/
   pound(ch);
   pound(f);
   return 0;
   }

   void pound(int n) /*n为形参。*/
   {
    while (n-- > 0) 
        printf("#");

    printf("\n");
   }
   ----------------------------

28.在C语言的while循环中，判断条件真假的值是0或1，但实际上，0为假，其他非零值都为真。关系表达式为真，求值得1;关系表达式为假，求值得0。 

29.逗号运算符把两个表达式连接成一个表达式，并保证最左边的表达式最先求值。逗号运算符通常在for循环头的表达式中用于包含更多的信息。整个逗号表达式的值是逗号右侧表达式的值。
   ----------------------------
   e.g.
   houseprice = 249,500;
          ==>
   houseprice = 249;
   500;
   ----------------------------

30.字符输入输出函数：getchar()和 putchar()。它们只处理字符。
   ----------------------------
   ch = getchar();
      ==>
   scanf("%c",&ch);

   putchar(ch);
      ==>
   printf("%c",&ch);

   while ((ch = getchar()) != '\n')
   ----------------------------

31.在C中的ctype.h头文件有字符函数，可了解。

32.判断 else 与 if 配对，如果没有花括号，else 与离它最近的 if 匹配，除非最近的 if 被花括号括起来。
   ----------------------------
   e.g.
   if (number > 6)
      if (number < 12)
         printf("You're close!\n"); 
   else
      printf("Sorry, you lose a turn!\n");
   ----------------------------
   else 与第2个 if 匹配。
   
   数字        响应
   5          None
   10         You’re close!
   15         Sorry, you lose a turn!

33.根据变量在某范围内决定程序流的去向，使用 switch 就很麻烦，这种情况用 if 就很方便:if (integer < 1000 && integer > 2) 。

34.在C中 goto 语句使程序控制跳转至相应标签语句。冒号用于分隔标签和标签语句。标签名遵循变量命名规则。标签语句可以出现在 goto 的前面或后面。

35.文件(file)是存储器中储存信息的区域。流(stream)是一个实际输入或输出映射的理想化数据流。
   打开文件的过程就是把流与文件相关联，而且读写都通过流来完成。检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾。一般可以使用内嵌的 Ctrl+Z 字符来标记文件结尾。
   在C语言中，用 getchar()读取文件检测到文件结尾时将返回一个特殊的值，即EOF（end of file的缩写）。scanf()函数检测到文件结尾时也返回EOF。
   EOF定义在stdio.h文件中：
      #define EOF(-1)

36.重定向输入运算符：<。
   e.g. echo_eof < words
   该运算符使words文件与stdin流相关联，把文件中的内容导入echo_eof程序。

37.重定向输出运算符：>。
   e.g. echo_eof > mywords
   它创建了一个名为mywords的新文件，然后把echo_eof的输出（即，你输入字符的副本）重定向至该文件中。

38.组合重定向
   -----------------------------
   e.g.
   echo_eof <mywords >savewords
   echo_eof >savewoeds >mywords   /*命令也起作用，因为命令与重定向运算符的顺序无关*/
   echo_eof <mywords >mywords    /*在一条命令中，输入文件名和输出文件名不能相同。*/
   -----------------------------
   绝大部分C系统都可以使用重定向，可以通过操作系统重定向所有程序，或只在C编译器允许的情况下重定向C程序。

39.在c中，scanf("%d",&a)可用来判断输出结果的个数。例如：if (scanf("%d",&a) == 1) 。

40.-----------------------------
   e.g.
   #include <stdio.h>
   void display(char cr, int lines, int width); 
   int main(void)
   {
       int ch; /* 待打印字符*/
       int rows, cols; /* 行数和列数 */
       printf("Enter a character and two integers:\n"); 
       while ((ch = getchar()) != '\n')
       {
           if (scanf("%d %d", &rows, &cols) != 2)
           break;
           display(ch, rows, cols); 
           while (getchar() != '\n') /*???????不解之处???????*/
               continue;
           printf("Enter another character and two integers;\n"); 
           printf("Enter a newline to quit.\n");
           
       } 
       printf("Bye.\n"); return 0;
   }
   void display(char cr, int lines, int width) {
       int row, col;
       for (row = 1; row <= lines; row++) {
           for (col = 1; col <= width; col++) 
               putchar(cr);
               putchar('\n'); /* 结束一行并开始新的一行 */ 
       }
   }
   ----------------------------
   运行程序时，输入数据，如：q 2 3。但是后面会按回车，这个'\n'也是一个数据输入，没有上面那个循环消耗'\n'，这个'\n'将会是下一个循环的字符ch，结束程序。

41.如果不初始 化数组，数组元素和未初始化的普通变量一样，其中储存的都是垃圾 值;但是，如果部分初始化数组，剩余的元素也会被初始化为0。

42.数组名是该数组首元素的地址。如：flizny == &flizny[0];。

43.从根本上看，指针(pointer)是一个值为内存地址的变量（或数据对象）。

44.地址运算符:&（取地址符）
   一般注解: 后跟一个变量名时，&给出该变量的地址。 
   示例:
   &nurse表示变量nurse的地址。

   地址运算符:*（间接运算符）
   一般注解: 后跟一个指针名或地址时，*给出储存在指针指向地址上的值。 
   示例:
   nurse = 22;
   ptr = &nurse; // 指向nurse的指针
   val = *ptr; // 把ptr指向的地址上的值赋给val 执行以上3条语句的最终结果是把22赋给val。

45.如：int zippo[4][2];数组名zippo是该数组首元素地址，zippo == &zippo[0],zippo[0] == &zippo[0][0] ==> **zippo == zippo[0][0] 或 *zippo == zippo[0]

46.----------------------------
   e.g.
   int (*pz)[2]; #1
   int *pax[2];  #2
   ----------------------------
   由于[]优先级高，#2式子是先与pax结合，所以pax成为一个内含两个元素的数组。然后*表示pax数组内含两个指针。最后，int表示pax数组中的指针都指向int类型的值。因此，这行代码声明了两个指向int的指针。
   而#1前面有圆括号，*先与pz结合，因此声明的是一个指向数组（内含两个int类型的值）的指针。

47.----------------------------
   e.g.
   int * pt;
   int (*pa)[3];
   int ar1[2][3];
   int ar2[3][2];
   int **p2;

   pt = &ar1[0][0]; //指向int的指针
   pt = ar1[0];     //指向int的指针
   pt = ar1;        //无效
   pa = ar1;        //指向内含3个int类型元素数组的指针
   pa = ar2;        //无效
   p2 = &pt;        //指向int的指针
   *p2 = ar2[0];    //指向int的指针
   p2 = ar2;        //无效
   ----------------------------
-----------------------------------------------------------
48.----------------------------
   e.g. 
   int main(void)
   {
      float candy[365];
      char code[12];
      int states[50];

   }
   ----------------------------
   candy,states是数字数组，code是字符数组，使用scanf("%s",&code)，就可以将字符作为字符串全部打印出来。

49.存储类型，在C中，有多种不同模型在内存中存储数据。每个被存储的值都占用一定物理内存，C语言把这样的一块内存称为对象。对象可以存储一个或多个值。

50.作用域。函数作用域(function scope)仅用于goto语句的标签。这意味着即 使一个标签首次出现在函数的内层块中，它的作用域也延伸至整个函数。如果在两个块中使用相同的标签会很混乱，标签的函数作用域防止了这样的事情发生。

51. fopen()的模式字符串
   模式字符串         含义
   "r"         |    以读模式打开文件。     
   "w"         |    以写模式打开文件，把现有文件的长度截为0，如果文件不存在，则创建一个新文件。
   "a"         |    以写模式打开文件，把现有文件末尾添加内容，如果文件不存在，则创建一个新文件。
   "r+"        |    以更新模式打开文件（即可读写文件）
   "w+"        |    以更新模式打开文件（即可以读写），如果文件存在，则将长度截为0；如果文件不存在，则创建一个新文件。
   "a+"        |    以更新模式打开文件（即可以读写），在现有文件末尾添加内容，如果文件不存在，则创建一个新文件；可以读写整个文件，从末尾添加内容。

52. getc()和putc()函数。getc()和getchar()函数类似。putc()和putchar()函数类似。

53.数组指针和指针数组。
   
   int *p1[10];    int (*p2)[10];

   “[]”的优先级比“*”要高。p1 先与“[]”结合，构成一个数组的定义，数组名为p1，int *修饰的是数组的内容，即数组的每个元素。那现在我们清楚，这是一个数组，其包含10 个指向int 类型数据的指针，即指针数组。

   至于p2 就更好理解了，在这里“()”的优先级比“[]”高，“*”号和p2 构成一个指针的定义，指针变量名为p2，int 修饰的是数组的内容，即数组的每个元素。数组在这里并没有名字，是个匿名数组。那现在我们清楚p2 是一个指针，它指向一个包含10 个int 类型数据的数组，即数组指针。

54.数组中 &a 和 a 。
   --------------------------
   e.g.
   #include <stdio.h>

   int main(void)
   {
      char a[5]={'A','B','C','D'};
      char (*p3)[5] = &a;
      char (*p4)[5] = a;

      char (*p5)[3] = &a;
      char (*p6)[3] = a;

      char (*p7)[10] = &a;
      char (*p8)[10] = a;

      printf("%d\n",&a[0]);

      printf("%d\n",*(p3+1));

      printf("%d\n",*(p4+1));

      printf("%d\n",*(p5+1));

      printf("%d\n",*(p6+1));

      printf("%d\n",*(p7+1));

      printf("%d\n",*(p8+1));

      return 0;
   }
   --------------------------
   -1639041021
   -1639041016
   -1639041016
   -1639041018
   -1639041018
   -1639041011
   -1639041011
   --------------------------
   &a 是整个数组的首地址，a是数组首元素的首地址，其值相同但意义不同。
   由结果可看出，根据指针类型及所指对象表示指针大小,每次加1,表示增加指针类型大小的字节。









